/*
 * System Interface Library for games
 * Copyright (c) 2007-2020 Andrew Church <achurch@achurch.org>
 * Released under the GNU GPL version 3 or later; NO WARRANTY is provided.
 * See the file COPYING.txt for details.
 *
 * src/test/utility/dds.c: Tests for the DDS file processing routines.
 */

#include "src/base.h"
#include "src/memory.h"
#include "src/test/base.h"
#include "src/texture.h"
#include "src/utility/dds.h"

/*************************************************************************/
/*************************************************************************/

DEFINE_GENERIC_TEST_RUNNER(test_utility_dds)

/*------------------------------------------------------------------------*/

/* Convenience macro for checking that a parse failure does not overwrite
 * the DDSInfo return buffer. */

#define CHECK_PARSE_FAIL(data,size)  do {               \
    DDSInfo info;                                       \
    memset(&info, 0xDD, sizeof(info));                  \
    CHECK_FALSE(dds_get_info((data), (size), &info));   \
    for (unsigned int i = 0; i < sizeof(info); i++) {   \
        const uint8_t byte = ((uint8_t *)&info)[i];     \
        if (byte != 0xDD) {                             \
            FAIL("DDSInfo was corrupted at byte %u"     \
                 " (0x%02X, should be 0xDD)", i, byte); \
        }                                               \
    }                                                   \
} while (0)

/*------------------------------------------------------------------------*/

TEST(test_basic)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16,  8,  0,   5,  0,  0,  0,
          4,  0,  0,  0,  80,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };

    DDSInfo info;
    memset(&info, 0xDD, sizeof(info));
    CHECK_TRUE(dds_get_info(data, sizeof(data), &info));
    CHECK_INTEQUAL(info.width, 4);
    CHECK_INTEQUAL(info.height, 5);
    CHECK_INTEQUAL(info.stride, 4);
    CHECK_INTEQUAL(info.format, TEX_FORMAT_RGBA8888);
    CHECK_INTEQUAL(info.mipmaps, 0);
    CHECK_PTREQUAL(info.data[0], &data[0x80]);
    for (int i = 1; i < lenof(info.data); i++) {
        CHECK_FALSE(info.data[i]);
    }

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_stride)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,  15, 16,  0,  0,   5,  0,  0,  0,
          2,  0,  0,  0,   4,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };

    DDSInfo info;
    memset(&info, 0xDD, sizeof(info));
    CHECK_TRUE(dds_get_info(data, sizeof(data), &info));
    CHECK_INTEQUAL(info.width, 2);
    CHECK_INTEQUAL(info.height, 5);
    CHECK_INTEQUAL(info.stride, 4);
    CHECK_INTEQUAL(info.format, TEX_FORMAT_RGBA8888);
    CHECK_INTEQUAL(info.mipmaps, 0);
    CHECK_PTREQUAL(info.data[0], &data[0x80]);
    for (int i = 1; i < lenof(info.data); i++) {
        CHECK_FALSE(info.data[i]);
    }

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_mipmap)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16, 10,  0,   2,  0,  0,  0,
          4,  0,  0,  0,  32,  0,  0,  0,   0,  0,  0,  0,   3,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   8, 16, 64,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,
    };

    DDSInfo info;
    memset(&info, 0xDD, sizeof(info));
    CHECK_TRUE(dds_get_info(data, sizeof(data), &info));
    CHECK_INTEQUAL(info.width, 4);
    CHECK_INTEQUAL(info.height, 2);
    CHECK_INTEQUAL(info.stride, 4);
    CHECK_INTEQUAL(info.format, TEX_FORMAT_RGBA8888);
    CHECK_INTEQUAL(info.mipmaps, 2);
    CHECK_PTREQUAL(info.data[0], &data[0x80]);
    CHECK_PTREQUAL(info.data[1], &data[0xA0]);
    CHECK_PTREQUAL(info.data[2], &data[0xA8]);
    for (int i = 3; i < lenof(info.data); i++) {
        CHECK_FALSE(info.data[i]);
    }

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_mipmap_single_level)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16, 10,  0,   2,  0,  0,  0,
          4,  0,  0,  0,  32,  0,  0,  0,   0,  0,  0,  0,   1,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };

    DDSInfo info;
    memset(&info, 0xDD, sizeof(info));
    CHECK_TRUE(dds_get_info(data, sizeof(data), &info));
    CHECK_INTEQUAL(info.width, 4);
    CHECK_INTEQUAL(info.height, 2);
    CHECK_INTEQUAL(info.stride, 4);
    CHECK_INTEQUAL(info.format, TEX_FORMAT_RGBA8888);
    CHECK_INTEQUAL(info.mipmaps, 0);
    CHECK_PTREQUAL(info.data[0], &data[0x80]);
    for (int i = 1; i < lenof(info.data); i++) {
        CHECK_FALSE(info.data[i]);
    }

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_mipmap_too_many_levels)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16, 10,  0,   1,  0,  0,  0,
          1,  0,  0,  0,  80,  0,  0,  0,   0,  0,  0,  0,  17,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   8, 16, 64,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,
    };

    DDSInfo info;
    memset(&info, 0xDD, sizeof(info));
    CHECK_TRUE(dds_get_info(data, sizeof(data), &info));
    CHECK_INTEQUAL(info.width, 1);
    CHECK_INTEQUAL(info.height, 1);
    CHECK_INTEQUAL(info.stride, 1);
    CHECK_INTEQUAL(info.format, TEX_FORMAT_RGBA8888);
    CHECK_INTEQUAL(info.mipmaps, 15);
    for (int i = 0; i < lenof(info.data); i++) {
        CHECK_PTREQUAL(info.data[i], &data[0x80+i*4]);
    }

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_formats_rgb)
{
    static uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16,  8,  0,   5,  0,  0,  0,
          4,  0,  0,  0,  80,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };
    static const struct {
        uint8_t ddspf[28];
        unsigned int format;
    } formats[] = {
        /* 32bpp */
        {{65,0,0,0, 0,0,0,0, 32,0,0,0, 0xFF,0,0,0,
          0,0xFF,0,0, 0,0,0xFF,0, 0,0,0,0xFF}, TEX_FORMAT_RGBA8888},
        {{65,0,0,0, 0,0,0,0, 32,0,0,0, 0,0,0xFF,0,
          0,0xFF,0,0, 0xFF,0,0,0, 0,0,0,0xFF}, TEX_FORMAT_BGRA8888},
        /* 16bpp */
        {{64,0,0,0, 0,0,0,0, 16,0,0,0, 0x1F,0,0,0,
          0xE0,0x07,0,0, 0,0xF8,0,0, 0,0,0,0}, TEX_FORMAT_RGB565},
        {{65,0,0,0, 0,0,0,0, 16,0,0,0, 0x1F,0,0,0,
          0xE0,0x03,0,0, 0,0x7C,0,0, 0,0x80,0,0}, TEX_FORMAT_RGBA5551},
        {{65,0,0,0, 0,0,0,0, 16,0,0,0, 0x0F,0,0,0,
          0xF0,0,0,0, 0,0x0F,0,0, 0,0xF0,0,0}, TEX_FORMAT_RGBA4444},
        {{64,0,0,0, 0,0,0,0, 16,0,0,0, 0,0xF8,0,0,
          0xE0,0x07,0,0, 0x1F,0,0,0, 0,0,0,0}, TEX_FORMAT_BGR565},
        {{65,0,0,0, 0,0,0,0, 16,0,0,0, 0,0x7C,0,0,
          0xE0,0x03,0,0, 0x1F,0,0,0, 0,0x80,0,0}, TEX_FORMAT_BGRA5551},
        {{65,0,0,0, 0,0,0,0, 16,0,0,0, 0,0x0F,0,0,
          0xF0,0,0,0, 0x0F,0,0,0, 0,0xF0,0,0}, TEX_FORMAT_BGRA4444},
        /* 8bpp */
        {{1,0,0,0, 0,0,0,0, 8,0,0,0, 0,0,0,0,
          0,0,0,0, 0,0,0,0, 0xFF,0,0,0}, TEX_FORMAT_A8},
    };

    for (int i = 0; i < lenof(formats); i++) {
        memcpy(&data[0x50], formats[i].ddspf, sizeof(formats[i].ddspf));
        DDSInfo info;
        info.format = ~formats[i].format;
        if (!dds_get_info(data, sizeof(data), &info)) {
            FAIL("dds_get_info(data, sizeof(data), &info) failed for"
                 " format %u", i);
        }
        if (info.format != formats[i].format) {
            FAIL("info.format was %u for format %u (expected %u)",
                 info.format, i, formats[i].format);
        }
    }

    static const uint8_t ddspf_alpha_invalid[28] = {
        65,0,0,0, 0,0,0,0, 32,0,0,0, 0xFF,0,0,0,
        0,0xFF,0,0, 0,0,0xFF,0, 0,0,0,0x11
    };
    memcpy(&data[0x50], ddspf_alpha_invalid, sizeof(ddspf_alpha_invalid));
    DDSInfo info;
    CHECK_FALSE(dds_get_info(data, sizeof(data), &info));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_formats_compressed)
{
    static uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16,  8,  0,   4,  0,  0,  0,
          4,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };
    static const struct {
        uint8_t ddspf[12];
        unsigned int format;
    } formats[] = {
        {{4,0,0,0, 'D','X','T','1', 4,0,0,0}, TEX_FORMAT_S3TC_DXT1},
        {{4,0,0,0, 'D','X','T','3', 8,0,0,0}, TEX_FORMAT_S3TC_DXT3},
        {{4,0,0,0, 'D','X','T','5', 8,0,0,0}, TEX_FORMAT_S3TC_DXT5},
    };

    for (int i = 0; i < lenof(formats); i++) {
        memcpy(&data[0x50], formats[i].ddspf, sizeof(formats[i].ddspf));
        data[0x14] = (4*4*data[0x58])/8;
        DDSInfo info;
        info.format = ~formats[i].format;
        if (!dds_get_info(data, sizeof(data), &info)) {
            FAIL("dds_get_info(data, sizeof(data), &info) failed for"
                 " format %u", i);
        }
        if (info.format != formats[i].format) {
            FAIL("info.format was %u for format %u (expected %u)",
                 info.format, i, formats[i].format);
        }
    }

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_short_magic)
{
    static const uint8_t data[] = {'D','D','S'};

    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_short_header)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16,  8,  0,   5,  0,  0,  0,
          4,  0,  0,  0,  80,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,
    };

    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_bad_magic)
{
    static const uint8_t data[] = {
        'd','d','s',' ', 124,  0,  0,  0,   7, 16,  8,  0,   5,  0,  0,  0,
          4,  0,  0,  0,  80,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };

    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_short_pixels)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16,  8,  0,   5,  0,  0,  0,
          4,  0,  0,  0,  80,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32,
    };

    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_short_data)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16,  8,  0,   5,  0,  0,  0,
          4,  0,  0,  0,  80,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32,
    };

    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_short_data_with_stride)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,  15, 16,  0,  0,   5,  0,  0,  0,
          2,  0,  0,  0,   4,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32,
    };

    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_invalid_width)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16,  8,  0,   5,  0,  0,  0,
          0,  0,  0,  0,  80,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };

    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_invalid_height)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16,  8,  0,   0,  0,  0,  0,
          4,  0,  0,  0,  80,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };

    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_invalid_stride)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,  15, 16,  0,  0,   5,  0,  0,  0,
          2,  0,  0,  0, 255,255,255,255,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,255,  0,   0,  0,  0,255,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };

    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_invalid_rgb_format)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16,  8,  0,   5,  0,  0,  0,
          4,  0,  0,  0,  80,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
         65,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0, 255,  0,  0,  0,
          0,255,  0,  0,   0,  0,127,  0,   0,  0,  0,255,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };

    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_invalid_fourcc)
{
    static const uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16,  8,  0,   4,  0,  0,  0,
          4,  0,  0,  0,  64,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
          4,  0,  0,  0, 'F','O','O','!',  32,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };

    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_invalid_dxt_bpp)
{
    static uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,   7, 16,  8,  0,   4,  0,  0,  0,
          4,  0,  0,  0,  64,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
          4,  0,  0,  0, 'D','X','T',  0,  32,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };

    data[0x57] = '1';
    CHECK_PARSE_FAIL(data, sizeof(data));
    data[0x57] = '3';
    CHECK_PARSE_FAIL(data, sizeof(data));
    data[0x57] = '5';
    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_compressed_with_stride)
{
    static uint8_t data[] = {
        'D','D','S',' ', 124,  0,  0,  0,  15, 16,  0,  0,   4,  0,  0,  0,
          4,  0,  0,  0,   4,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,  32,  0,  0,  0,
          4,  0,  0,  0, 'D','X','T','1',  32,  0,  0,  0,   0,  0,  0,  0,
          0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0, 16,  0,  0,
          0,  0,  0,  0, 'D','D','S','X', 255,255,255,255, 255,255,255,255,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
         12, 23, 34, 45,  56, 67, 78, 89,  98, 87, 76, 65,  54, 43, 32, 21,
    };

    CHECK_PARSE_FAIL(data, sizeof(data));

    return 1;
}

/*------------------------------------------------------------------------*/

TEST(test_invalid_params)
{
    static const uint8_t data[] = {'D', 'D', 'S', ' '};
    DDSInfo info;

    CHECK_FALSE(dds_get_info(NULL, sizeof(data), &info));
    CHECK_FALSE(dds_get_info(data, sizeof(data), NULL));

    return 1;
}

/*************************************************************************/
/*************************************************************************/
